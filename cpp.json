{	
	"cout" : {
		"prefix" : "cout",
		"body" : [
			"cout << $1 << endl;"
		]
	},
	"ccout" : {
		"prefix" : "ccout",
		"body" : [
			"cout << $1 << ' ' << $2 << endl;"
		]
	},
	"cccout" : {
		"prefix" : "cccout",
		"body" : [
			"cout << $1 << ' ' << $2 << ' ' << $3 << endl;"
		]
	},
	"printf" : {
		"prefix" : "printf",
		"body" : [
			"printf(\"%d %d\\n\", $1, $2);"
		]
	},
	"cin" : {
		"prefix" : "cin",
		"body" : [
			"cin >> $1;"
		]
	},	
	"ccin" : {
		"prefix" : "ccin",
		"body" : [
			"cin >> $1 >> $2;"
		]
	},
	"cccin" : {
		"prefix" : "cccin",
		"body" : [
			"cin >> $1 >> $2 >> $3;"
		]
	},
	"vector" : {
		"prefix" : "vec",
		"body" : [
			"vector<$1> $2;"
		]
	},
	"vector<int>" : {
		"prefix" : "vi",
		"body" : [
			"vector<int> $1($2);"
		]
	},
	"vector<string>" : {
		"prefix" : "vs",
		"body" : [
			"vector<string> $1($2);"
		]
	},
	"vector<string> string" : {
		"prefix" : "vss",
		"body" : [
			"vector<string> $1($2, string($3, '$4'));"
		]
	},
	"vector<bool>" : {
		"prefix" : "vb",
		"body" : [
			"vector<bool> $1;"
		]
	},
	"vector<P>" : {
		"prefix" : "vp",
		"body" : [
			"vector<P> p;"
		]
	},
	"vector<vector<>>" : {
		"prefix" : "vvec",
		"body" : [
			"vector<vector<$1>> $2($3, vector<$1>($4));"
		]
	},
	"vector<vector<int>>" : {
		"prefix" : "vvi",
		"body" : [
			"vector<vector<int>> $1($2, vector<int>($3));"
		]
	},
	"vector<vector<string>>" : {
		"prefix" : "vvs",
		"body" : [
			"vector<vector<string>> $1($2, vector<string>($3, string($4, '$5'));"
		]
	},
	"vector<vector<bool>>" : {
		"prefix" : "vvb",
		"body" : [
			"vector<vector<bool>> $1($2, vector<bool>($3));"
		]
	},
	"vector<vector<vector<>>>" : {
		"prefix" : "vvvec",
		"body" : [
			"vector<vector<vector<$1>>> $2($3, vector<vector<$1>>($4, vector<$1>($5)));"
		]
	},
	"for" : {
		"prefix" : "for",
		"body" : [
			"for (int ${1:i} = ${2:0}; ${1:i} < ${3:N}; ++${1:i}) {$4}"
		]
	},
  "rep" : {
    "prefix" : "rep",
    "body" : [
      "rep(${1:i},${2:n}) $3"
    ]
  },
  "nrep" : {
	"prefix" : "nrep",
	"body" : [
		"nrep(${1:i},$2,${3:n}) $4"
	]
  },
  "rrep" : {
    "prefix" : "rrep",
    "body" : [
      "rep(${1:i},${2:h}) rep(${3:j},${4:w}) {$5}"
    ]
  },
	"long long" : {
		"prefix" : "ll",
		"body" : [
			"long long $1;"
		]
	},
	"pair" : {
		"prefix" : "pair",
		"body" : [
			"pair<$1, ${2:$1}> $3;"
		]
	},
	"using pair" : {
		"prefix" : "using p",
		"body" : [
			"using P = pair<$1, ${2:$1}>;"
		]
	},
	"using mint" : {
		"prefix" : "mint",
		"body" : [
			"using mint = modint998244353;"
		]
	},
	"abc" : {
		"prefix" : "abc",
		"body" : [
			"abcdefghijklmnopqrstuvwxyz"
		]
	},
	"ABC" : {
		"prefix" : "ABC",
		"body" : [
			"ABCDEJGHIJKLMNOPQRSTUVWXYZ"
		]
	},
	"x.begin(),x.ene()" : {
		"prefix" : "all",
		"body" : [
			"$1.begin(), $1.end()"
        ]
	},
	"set" : {
		"prefix" : "set",
		"body" : [
			"set<$1> $2;"
		]
	},
	"unordered_set" : {
		"prefix" : "uset",
		"body" : [
			"unordered_set<$1> $2;"
		]
	},
	"insert" : {
		"prefix" : "ins",
		"body" : [
			"insert($1);"
		]
	},
	"push_back" : {
		"prefix" : "pb",
		"body" : [
			"push_back($1);"
		]
	},
	"emplace_back" : {
		"prefix" : "eb",
		"body" : [
			"emplace_back($1);"
		]
	},
	"priority_queue" : {
		"prefix" : "pq",
		"body" : [
			"priority_queue<$1> $2;"
		]
	},
	"lambda expressions" : {
		"prefix" : "lam",
		"body" : [
			"auto $1 = [&]($2) {",
			"    $3",
			"};"
		]
	},
	"exchange_decimal_number" : {
		"prefix" : "ten",
		"body" : [
			"auto ten = [&](string s) {",
			"    ll x = 0;",
			"    for (char c : s) x = x*2+(c-'0');",
			"    return x;",
			"};"
		],
        "description": "10進数変換"
	},
	"N_numbers" : {
		"prefix" : "num",
		"body" : [
			"auto number = [&](ll n) -> string {",
			"    if (n==0) return \"0\";",
			"    string res;",
			"    while (n > 0) {",
			"        res = char(n % $1 + '0') + res;",
			"        n /= $1;",
			"    }",
			"    return res;",
			"};"
		],
		"description": "10進数 -> N進数"
	},
	"sort" : {
		"prefix" : "sort",
		"body" : [
			"sort($1.begin(), $1.end());"
		]
	},
	"rsort" : {
		"prefix" : "rsort",
		"body" : [
			"sort($1.begin(), $1.end(), greater<int>());"
		]
	},
	"stable_sort" : {
		"prefix" : "ssort",
		"body" : [
			"stable_sort($1.begin(), $1.end());"
		]
	},
	"lambda_sort" : {
		"prefix" : "lsort",
		"body" : [
			"sort($1.begin(), $1.end(), [&]($2){",
			"    $3",
			"});"
		]
	},
	"rotate" : {
		"prefix" : "rot",
		"body" : [
			"rotate($1.begin(), $1.begin()+$2, $1.end());"
		]
	},
	"vmax" : {
		"prefix" : "vmax",
		"body" : [
			"*max_element($1.begin(), $1.end());"
		]
	},
	"vmin" : {
		"prefix" : "vmin",
		"body" : [
			"*min_element($1.begin(), $1.end());"
		]
	},
	"find" : {
		"prefix" : "find",
		"body" : [
			"find($1.begin(), $1.end(), $2);"
		]
	},
	"reverse" : {
		"prefix" : "rev",
		"body" : [
			"reverse($1.begin(), $1.end());"
		]
	},
	"8move" : {
		"prefix" : "8move",
		"body" : [
			"const int di[] = {1,0,-1,0,1,-1,-1,1};",
			"const int dj[] = {0,1,0,-1,1,1,-1,-1};"
		]
	},
	"next_permutation" : {
		"prefix" : "np",
		"body" : [
			"sort($1.begin(), $1.end());",
			"do{",
			"    $2",
			"} while(next_permutation($1.begin(), $1.end()));"
		]
	},
	"binary_search" : {
		"prefix" : "bs",
		"body" : [
			"int left = $1, right = $2;",
			"while(right - left > 1) {",
			"    int mid = (left + right) / 2;",
			"    if (solve(mid)) left = mid;",
			"    else right = mid;",
			"}"
		]
	},
	"lower_bound" : {
		"prefix" : "lb",
		"body" : [
			"lower_bound($1.begin(), $1.end(), $2) - $1.begin();"
		]
	},
	"upper_bound" : {
		"prefix" : "ub",
		"body" : [
			"upper_bound($1.begin(), $1.end(), $2) - $1.begin();"
		]
	},
	"accumulative2" : {
		"prefix" : "ac",
		"body" : [
			"rep(i,h+1)rep(j,w) $1[i][j+1] += $1[i][j];",
			"rep(i,h)rep(j,w+1) $1[i+1][j] += $1[i][j];",
			"auto sum = [&](int li, int lj, int ri, int rj) {",
			"    return $1[ri][rj] - $1[li][rj] - $1[ri][lj] + $1[li][lj];",
			"};"
		],
		"description": "2次元累積和"
	},
	"chmin" : {
		"prefix" : "chmin",
		"body" : [
			"template<typename T> inline bool chmin(T &a, const T& b) { return ((a > b) ? (a = b, true) : (false)); };"
		]
	},
	"chmax" : {
		"prefix" : "chmax",
		"body" : [
			"template<typename T> inline bool chmax(T &a, const T& b) { return ((a < b) ? (a = b, true) : (false)); };"
		]
	},
	"vector_debug" : {
		"prefix" : "vdeg",
		"body" : [
			"for(auto e : $1) cout << e << ' ';"
		]
	},
	"vector<vector>_debug" : {
		"prefix" : "vvdeg",
		"body" : [
			"for(int i=0; i<$1.size(); ++i){",
			"    for(int j=0; j<$1[0].size(); ++j){",
			"        cout << $1[i][j] << ' ';",
			"    }",
			"    cout << endl;",
			"}"
		]
	},
	"space_endl" : {
		"prefix" : "space",
		"body" : [
			"(i!=n-1 ? ' ' : '\\n');"
		]
	},
	"POW18" : {
		"prefix" : "pow18",
		"body" : [
			"ll pow18 = 1000000000000000000LL;"
		]
	},
	"INF" : {
		"prefix" : "inf",
		"body" : [
			"const int INF = 1001001001;"
		]
	},
	"10**9+7" : {
		"prefix" : "107",
		"body" : [
			"1000000007"
		]
	},
	"ACL" : {
		"prefix" : "acl",
		"body" : [
			"#include <atcoder/all>",
			"using namespace atcoder;"
		]
	},
	"lcm" : {
		"prefix" : "lcm",
		"body" : [
			"auto lcm = [&](ll a, ll b) {",
			"    ll ret = a * b / gcd(a,b);",
			"    return ret;",
			"};"
		]
	},
	"modPow" : {
		"prefix" : "modPow",
		"body" : [
			"long long modPow (int a, long long b) {",
			"    int ans = 1;",
			"    while (b != 0) {",
			"        if (b % 2 == 1) {",
			"            ans = (long long)(ans)*a % mod;",
			"        }",
			"        a = (long long)(a)*a % mod;",
			"        b /= 2;",
			"    }",
			"    return ans;",
			"}"
		]
	},
	"isPalindrome" : {
		"prefix" : "ispal",
		"body" : [
			"auto isPalindrome(string s) -> bool {",
			"    string t = s;",
			"    reverse(t.begin(), t.end());",
			"    return s == t;",
			"}"
		]
	},
	"bfs" : {
		"prefix" : "bfs",
		"body" : [
			"while(!q.empty()) {",
			"    ${1:auto [a,b]} = q.front(); q.pop();",
			"    $2",
			"}"
		]
	},
	"lambda_bfs" : {
		"prefix" : "lbfs",
		"body" : [
			"auto bfs = [&](int sv) {",
			"    const int INF = 1001001001;",
			"    vector<int> dist(n, INF);",
			"    queue<int> q;",
			"    q.push(sv); dist[sv] = 0;",
			"    while(!q.empty()) {",
			"        int v = q.front(); q.pop();",
			"        for (int u : to[v]) {",
			"            if (dist[u] != INF) continue;",
			"            dist[u] = dist[v] + 1;",
			"            q.push(u);",
			"        }",
			"    }",
			"    return dist;",
			"};"
		]
	},
	"lambda_dfs" : {
		"prefix" : "ldfs",
		"body" : [
			"auto dfs = [&](auto dfs, $1) -> void {",
			"    $2",
			"};",
			"dfs(dfs, 0);"
		]
	},
	"Eratosthenes" : {
		"prefix" : "era",
		"body" : [
			"struct Sieve {",
			"    int n;",
			"    vector<int> f, primes;",
			"    Sieve(int n=1):n(n), f(n+1) {",
			"        f[0] = f[1] = -1;",
			"        for (ll i = 2; i <= n; ++i) {",
			"            if (f[i]) continue;",
			"            primes.push_back(i);",
			"            f[i] = i;",
			"            for (ll j = i*i; j <= n; j += i) {",
			"                if (!f[j]) f[j] = i;",
			"            }",
			"        }",
			"    }",
			"    bool isPrime(int x) { return f[x] == x; }",
			"    vector<int> factorList(int x) {",
			"        vector<int> res;",
			"        while (x != 1) {",
			"            res.push_back(f[x]);",
			"            x /= f[x];",
			"        }",
			"        return res;",
			"    }",
			"    vector<P> factor(int x) {",
			"        vector<int> f1 = factorList(x);",
			"        if (f1.size() == 0) return {};",
			"        vector<P> res(1, P(f1[0], 0));",
			"        for (int p : f1) {",
			"            if (res.back().first == p) {",
			"                res.back().second++;",
			"            } else {",
			"                res.emplace_back(p, 1);",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    vector<pair<ll,int>> factor(ll x) {",
			"        vector<pair<ll,int>> res;",
			"        for (int p : primes) {",
			"            int y = 0;",
			"            while (x%p == 0) x /= p, ++y;",
			"            if (y != 0) res.emplace_back(p,y);",
			"        }",
			"        if (x != 1) res.emplace_back(x,1);",
			"        return res;",
			"    }",
			"};"
		]
	},
	"main()" : {
		"prefix" : "main",
		"body" : [
			"#include <bits/stdc++.h>",
			"using namespace std;",
            "#define rep(i,n) for (int i = 0; i < (n); ++i)",
			"#define nrep(i,s,n) for(int i = (s); i < (n); ++i)",
			"using P = pair<int, int>;",
			"using ll = long long;",
			"",
			"int main() {",
			"    $1",
		    "    return 0;",
			"}"
		]
	},
	"union find" : {
		"prefix" : "uf",
		"body" : [
			"int n, m;",
			"cin >> n >> m;",
			"",
			"dsu uf(n);",
			"rep(i,m) {",
			"    int a, b;",
			"    cin >> a >> b;",
			"    a--; b--;",
			"    uf.merge(a,b);$1",
			"}",
			"",
			"$2"
		]
	},
	"graph" : {
		"prefix" : "graph",
		"body" : [
			"int n, m;",
			"cin >> n >> m;",
			"vector<vector<int>> to(n);",

			"rep(i,m) {",
			"    int a, b;",
			"    cin >> a >> b;",
			"    --a; --b;",
			"    to[a].push_back(b);",
			"    to[b].push_back(a);",
			"}"
		]
	},
	"solve" : {
		"prefix" : "solve",
		"body" : [
			"#include <bits/stdc++.h>",
			"using namespace std;",
            "#define rep(i,n) for (int i = 0; i < (n); ++i)",
			"#define nrep(i,s,n) for(int i = (s); i < (n); ++i)",
			"using P = pair<int, int>;",
			"using ll = long long;",
			"",
			"bool solve() {",
			"    $1",
			"}",
			"",
			"int main() {",
			"    cout << (solve() ? \"Yes\" : \"No\");",
		    "    return 0;",
			"}"
		]
	},
	"query" : {
		"prefix" : "query",
		"body" : [
			"int Q;",
			"cin >> Q;",
			"",
			"rep(qi,Q) {",
			"    int type;",
			"    cin >> type;",
			"    if (type == 1) {",
			"        int x;",
			"        cin >> x;",
			"        $1;",
			"    }",
			"    if (type == 2) {",
			"        $2",
			"    }",
			"    if (type == 3) {",
			"        $3",
			"    }",
			"}",
			"",
			"$4"
		]
	},
	"square" : {
		"prefix" : "square",
		"body" : [
			"int h, w;",
			"cin >> h >> w;",
			"vector<string> s(h);",
			"rep(i,h) cin >> s[i];",
			"",
			"// 検出した四角形の走査",
			"auto scan = [&](int li, int lj, int ri, int rj) {",
			"    for (int i=li; i<=ri; ++i) {",
			"        for (int j=lj; j<=rj; ++j) {",
			"            $1",
			"        }",
			"    }",
			"};",
			"",
			"// 四角形の左上と右下検出",
			"int li = h, lj = w, ri = 0, rj = 0;",
			"rep(i,h) rep(j,w) {",
			"    if (s[i][j] == '#'){",
			"        li = min(i, li);",
			"        lj = min(j, lj);",
			"        ri = max(i, ri);",
			"        rj = max(j, rj);",
			"    }",
			"}",
			"",
			"$2"
		]
	}
}
